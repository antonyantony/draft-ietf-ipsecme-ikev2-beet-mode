<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- <xi:strict="yes" ?>
<xi:compact="yes" ?>
<xi:subcompact="no" ?>  -->
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std" docName="draft-antony-ipsecme-beet-mode-00" ipr="trust200902" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" tocDepth="4" symRefs="true" sortRefs="true" version="3" consensus="true">
  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->
    <title abbrev="BEET mode for ESP">A Bound End-to-End Tunnel (BEET) mode for ESP </title>
    <!-- add 'role="editor"' below for the editors if appropriate -->
    <!-- Another author who claims to be an editor -->
    <author fullname="Antony Antony" initials="A." surname="Antony">
      <organization abbrev="secunet">secunet Security Networks AG</organization>
      <address>
        <email>antony.antony@secunet.com</email>
      </address>
    </author>
    <area>sec</area>
    <workgroup>IPSECME Working Group</workgroup>
    <keyword>IKEv2</keyword>
    <keyword>BEET</keyword>
    <abstract>
      <t>
    This document specifies a new mode for IPsec ESP, known as the Bound
		End-to-End Tunnel (BEET) mode. This mode complements the existing ESP tunnel
		and transport modes, enhancing end-to-end tunnels. It offers the
		characteristics of tunnel mode but without its usual overhead. The mode is
		designed to accommodate evolving applications of ESP, such minimalist tunnel
		mode endpoint, mobility and multi-address multi-homing. Additionally, this
		document proposes a new Notifier, USE_BEET_MODE, for the
		Internet Key Exchange Protocol Version 2 (IKEv2) specified in
		<xref target="RFC7296"/>, to facilitate BEET mode Security Association
		negotiation.
    </t>
    </abstract>
  </front>
  <middle>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <t>
   The current IPsec ESP specification <xref target="RFC4303"/> defines two
	 modes of operation: tunnel mode and transport mode.  The tunnel mode is mainly
   intended for non-end-to-end use where one or both of the ends of the
   ESP Security Associations (SAs) are located in security gateways,
   separate from the actual end-nodes.  The transport mode is intended
   for end-to-end use, where both ends of the security association are
   terminated at the end-nodes themselves.

   This document defines a new mode for ESP, called Bound End-to-End
   Tunnel (BEET) mode.  The purpose of the mode is to provide limited
   tunnel mode semantics without the overhead associated with the
   regular tunnel mode.  As the name states, the BEET mode is intended
   solely for end-to-end use.  It provides tunnel mode semantics in the
   sense that the IP addresses seen by the applications and the IP
   addresses used on the wire are distinct from each other, providing
   the illusion that the application level IP addresses are tunneled
   over the network level IP addresses.  However, the mode does not
   support full tunnel semantics.  More specifically, the IP addresses
   as seen by the application are strictly bound, and only one pair of
   bound inner addresses can be used on any given BEET mode Security
   Association.  This is in contrast to the regular tunnel mode, where
   the inner IP addresses can be any addresses from a defined range.

   A BEET mode Security Associations records two pairs of IP addresses,
   called inner addresses and outer addresses.  The inner addresses are
   what the applications see.  The outer addresses are what appear on
   the wire.  Since the inner addresses are fixed for the lifetime of
   the Security Association, they need not to be sent in individual
   packets.  Instead, they are set up as the Security Associations are
   created, they are verified when packets are sent, and they are
   restored as packets are received.

   This all gives the BEET mode the efficiency of transport mode with a
   limited set of end-to-end tunnel semantics.  The efficiency is
   accomplished by removing the inner IP header from the packet that is
   transported on the wire.  Due to removal of inner IP header, the TTL
   of tunneled packet is reduced by every router on the path as the TTL
   value is copied from inner to outer header by the sender and vice
   versa by the receiver.  The semantics of BEET mode is limited in the
   sense that only one fixed pair of inner addresses are allowed.  The
   outer addresses may change over the life time of the SA, but the
   inner addresses cannot.  If a new pair of inner addresses is needed,
   a new pair of BEET mode Security Associations must be established, or
   the regular tunnel mode must be used.  However, in the cases
   considered, a single pair of security associations is usually
   sufficient between any single pair of nodes.
      </t>
      <section numbered="true" toc="default">
        <name>Requirements Language</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
       "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
       document are to be interpreted as described in
			 <xref target="RFC2119" format="default">RFC 2119</xref>.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Terminology</name>
        <t>
       In this section we define the terms specific to this document.  This
   section is normative.
				</t>
        <ul>
          <li> Inner IP address :
      An IP address as seen by applications, stored in TCP or other
      upper layer data structures, and processed by the IP stack prior
      to ESP processing in the output side and after ESP processing in
      the input side.
			</li>
          <li>
      Outer IP address: An IP address seen on the wire and processed by the IP
			stack after ESP processing in the output side and before ESP processing
			in the input side.
			</li>
          <li>
      Inner IP header: An IP header that contains inner IP addresses.  In some cases an
      inner IP header may be represented as an internal data structure
      containing the data equivalent to an IP header.</li>
          <li>
      Outer IP header: An IP header that contains outer IP addresses.  In some cases an
      outer IP header may be represented as an internal data structure
      containing the data equivalent to an IP header.  </li>
        </ul>
      </section>
    </section>
    <section anchor="Background" numbered="true" toc="default">
      <name>Background</name>
      <t>TBD	The following the old background may be re-write it? </t>
      <t>
   For a number of years people have been talking about using IPsec for
   other purposes than VPN.  In fact, the current specifications do
   provide support for end-to-end protection of data.  However, that
   mode is rarely used, for a number of reasons [6], [7].  One of the
   reasons, though, seems to be address agility.  That is, due to NAT,
   mobility, multi-address multi-homing, etc., the addresses that are
   used actually on the wire do not necessarily match with the addresses
   that the applications expect to see.  In the NAT case the addresses
   are changed on the fly, thereby invalidating any transport mode
   checksums (unless, of course, a tunnel is used).  Mobile nodes change
   their addresses periodically, and the existing applications rarely
   survive the address changes without some help, e.g., Mobile IP.
   Multi-addressing based multi-homed nodes would prefer to keep their
   connections active even when the primary (or currently used) IP
   address becomes unusable in the face of an network outage.

   Based on the reasons above, there is clearly a need for a mode of
   communication where the addresses that the applications see are
   distinct from the addresses that are actually used in the wire.  The
   current IPsec tunnel mode provides the required functionality, but at
   the cost of additional overhead in terms of larger packets and more
   complicated processing. </t>
      <section anchor="Related" numbered="true" toc="default">
        <name>Related work</name>
        <t> The basic idea captured by this draft has been floating around for a
   long time.  Steven Bellovin's HostNAT talk [8] and
	 at the Los Angeles
   IETF is an early example, and this ID is based on BEET mode ID
	 an pervious ID <xref target=" I-D.nikander-esp-beet-mode"/>.
   After that, basically the same idea has surfaced several times.
   Perhaps the most concrete current proposal
   is the Host Identity Protocol (HIP) <xref target="RFC5201"/> and <xref target="RFC5202"/> where BEET
	 mode ESP processing is an integral part of the overall protocol. [AA verify this part is it still used by  updated RFC 7401]
	 Minimal ESP <xref target="RFC9333"/> also propose to use BEET mode. </t>
      </section>
    </section>
    <section anchor="Use" numbered="true" toc="default">
      <name>Use scenarios</name>
      <t>
  In this section we describe a number of possible use scenarios.  None
  of these use scenarios are meant to be complete specifications on how
  exactly to support the functionality.  Separate specifications are
  needed for that.  Instead, the purpose of this section is to discuss
  the overall benefits of the BEET mode, and to lay out a road map for
  possible future documents.  This section is informative.
      </t>
      <section anchor="IPsec-minimal" numbered="true" toc="default">
        <name>Minimal IPsec for end-to-end</name>
        <t> Over the years BEET is used widely as minimal IPsec tunnel for
				end-to-end scenearios to reduce bytes send over the wire, <xref target="RFC9333"/> </t>
      </section>
      <section anchor="NAT-T" numbered="true" toc="default">
        <name>NAT traversal</name>
        <t>
   NAT traversal is currently a major problem in IPsec.  It is not
   sufficient to encapsulate the packets into UDP; additionally, tunnel mode
   must be used when there are multiple clients behind the same NAT.
   Tunnel mode is required since the outer IP addresses at the ends of the
   protected connection differ.  If transport mode was used, the differing
   IP addresses would lead  to failing upper layer TCP/UDP checksums.  </t>
        <t>
	 The BEET mode provides sufficient tunnel mode semantics without the
   packet overhead of the tunnel mode.  A pair of BEET mode SAs can be
   effectively used to "un-NAT" packets that have been NATed during
   their travel through the network.  Figure 1 illustrates the process. </t>
      </section>
      <section anchor="End-node-multihome" numbered="true" toc="default">
        <name>End-node multi-address multi-homing</name>
        <t>
         The BEET mode provides for limited end-node multi-address multi-
   homing.  It semantically provides a tunnel between the end-hosts,
   with fixed inner IP addresses.  This allows a multi-homed host to use
   different outer IP addresses in different packets, without any notice
   by the upper layer protocols.  The upper layer protocols see the
   inner IP address at all times.  Thus, this limited form of multi-
   homing has no affect on the applications, which seemingly communicate
   over fixed IP addresses all the time. </t>
        <t>
   Implementing this kind of limited multi-homing support would require
   a small change to the current IPsec SPD and SA implementations.
   Currently the incoming SA selection is based on the SPI and
   destination address, with the implicit assumption that there is only
   one possible destination address for each incoming SA.  In a multi-
   homed host it would be desirable to have multiple destination
   addresses associated with the SA, thereby allowing the same SA to be
   used independent on the actual destination address in the packets.
   Removing the destination address from unicast SA lookup is already
   being proposed in the current ESP draft <xref target="RFC4303"/>. </t>
        <t>
   If it is considered undesirable to change the implementations to
   support multiple alternative destination addresses, it would still be
   possible to support limited multi-homing by creating several parallel
   SAs, one for each destination address.  Each of these SAs would have
   identical inner addresses.  Effectively, this would distribute the
   tunnel over multiple SAs. </t>
        <t>
   In this latter implementation, the outgoing SA processing becomes
   more complex.  Selecting the outgoing SA does not depend only on the
   inner IP addresses but also on the outer destination address.
   Selecting the outer destination address depends on the current multi-
   homing situation.  This creates a situation where the SA processing
   must be deferred after selecting the actual outer address to be used.
   This might be difficult in some implementations. </t>
      </section>
    </section>
    <section anchor="Protocol-definition" numbered="true" toc="default">
      <name>Protocol Definition</name>
      <t>
   In this section we define the exact protocol formats and operations. This section is normative.
   </t>
      <section anchor="Changes-SA" numbered="true" toc="default">
        <name>Changes to Security Association data structure</name>
        <t>
   A BEET mode Security Association contains the same data as a regular
   tunnel mode Security Association, with the exception that the inner
   selectors must be single addresses and cannot be subnets.  The data
   includes the following: </t>
        <ul>
          <li> A pair of inner IP addresses.</li>
          <li>A pair of outer IP addresses. </li>
          <li>Cryptographic keys and other data as defined in <xref target="RFC2401"/> Section 4.4.3. </li>
        </ul>
        <t> A conforming implementation MAY store the data in a way similar to a
   regular tunnel mode Security Association.

   Note that in a conforming implementation the inner and outer
   addresses MAY belong to different address families.  All
   implementations that support both IPv4 and IPv6 SHOULD support both
   IPv4-over-IPv6 and IPv6-over-IPv4 tunneling.
   </t>
      </section>
      <section anchor="Packet-format" numbered="true" toc="default">
        <name>Packet format</name>
        <t>
   The wire packet format is identical to the ESP transport mode wire
   format as defined in  <xref target="RFC4303"/> Section 3.1.1.  However,
	 the resulting packet contains outer IP addresses instead of the inner IP addresses
   received from the upper layer.  The construction of the outer headers
   is defined in <xref target="RFC2401"/> Section 5.1.2.  The following diagrams
   illustrates ESP BEET mode positioning for typical IPv4 and IPv6
   packets. </t>
      </section>
      <section anchor="InnerIPv4" numbered="true" toc="default">
        <name>Inner IPv4 Datagram</name>
        <figure anchor="inneripv4before" align="center">
          <name>IPv4 INNER DATAGRAM BEFORE APPLYING ESP</name>
          <artwork align="left"><![CDATA[
    ------------------------------
    | inner IP hdr  | TCP | Data  |
    ------------------------------
		     ]]></artwork>
        </figure>
        <figure align="center" anchor="afterespouteripv4">
          <name> AFTER APPLYING ESP, OUTER v4 ADDRESSES </name>
          <artwork align="left"><![CDATA[
    ----------------------------------------------------
    | outer IP hdr  |     |     |      |   ESP   | ESP |
    | (any options) | ESP | TCP | Data | Trailer | ICV |
    ----------------------------------------------------
                          |<---- encryption ---->|
                    |<-------- integrity ------->|
				]]></artwork>
        </figure>
        <figure align="center" anchor="afterespouteripv6">
          <name>AFTER APPLYING ESP, OUTER v6 ADDRESSES</name>
          <artwork align="left"><![CDATA[
    --------------------------------------------------------
    | outer    | new ext |     |     |      |  ESP   | ESP |
    | IPv6 hdr | hdrs.   | ESP | TCP | Data | Trailer| ICV |
    --------------------------------------------------------
                             |<--- encryption ---->|
                       |<------- integrity ------->|
				]]></artwork>
        </figure>
        <figure align="center" anchor="ipv4inneroptions">
          <name>IPv4 INNER DATAGRAM with IP options BEFORE APPLYING ESP</name>
          <artwork align="left"><![CDATA[
    ------------------------------
    | inner IP hdr  |     |      |
    |  + options    | TCP | Data |
    ------------------------------
				]]></artwork>
        </figure>
        <figure align="center" anchor="ipv4outeroptions">
          <name>IPv4 AFTER APPLYING ESP, OUTER v4 ADDRESSES INNER IPv4 OPTIONS </name>
          <artwork align="left"><![CDATA[
    ----------------------------------------------------------
    | outer IP hdr  |     |     |     |      |   ESP   | ESP |
    | (any options) | ESP | PH  | TCP | Data | Trailer | ICV |
    ----------------------------------------------------------
                          |<------- encryption ------->|
                    |<----------- integrity ---------->|
	  PH = Pseudo Header for IPv4 options from inner datagram.
        ]]></artwork>
        </figure>
      </section>
      <section anchor="InnerIPv6" numbered="true" toc="default">
        <name>Inner IPv6 Datagram</name>
        <figure align="center" anchor="ipv6beforeesp">
          <name> IPv6 DATAGRAM BEFORE APPLYING ESP </name>
          <artwork align="left"><![CDATA[
    --------------------------------------------
		|                |  ext hdrs  |     |      |
		| inner IPv6 hdr | if present | TCP | Data |
    --------------------------------------------
					]]></artwork>
        </figure>
        <figure align="center" anchor="ipv6afteresp">
          <name> IPv6 DATAGRAM AFTER APPLYING ESP, OUTER v6 ADDRESSES </name>
          <artwork align="left"><![CDATA[
    --------------------------------------------------------------
    | outer  | new ext |     | dest |     |      |  ESP    | ESP |
    | IP hdr | hdrs.   | ESP | opts.| TCP | Data | Trailer | ICV |
    --------------------------------------------------------------
                                    |<---- encryption ---->|
                                |<------- integrity ------>|
					]]></artwork>
        </figure>
        <figure align="center" anchor="ipv6afterespipv6">
          <name> IPv6 DATAGRAM AFTER APPLYING ESP, OUTER IPv6 ADDRESSES </name>
          <artwork align="left"><![CDATA[
    ----------------------------------------------------------------
    | outer    | new ext |     | dest |     |      |  ESP    | ESP |
    | IPv6 hdr | hdrs.   | ESP | opts.| TCP | Data | Trailer | ICV |
    ----------------------------------------------------------------
                                    |<---- encryption ---->|
                                |<------- integrity ------>|
					]]></artwork>
        </figure>
        <figure align="center" anchor="ipv6afterespipv4">
          <name> IPv6 DATAGRAM AFTER APPLYING ESP, OUTER IPv4 ADDRESSES </name>
          <artwork align="left"><![CDATA[
    ---------------------------------------------------------
    | outer  |     | PH        |     |      |  ESP    | ESP |
    | IP hdr | ESP | dest opts.| TCP | Data | Trailer | ICV |
    ---------------------------------------------------------
                   |<------- encryption -------->|
             |<----------- integrity ----------->|
	  PH = Pseudo Header for IPv6 options from inner datagram.
					]]></artwork>
        </figure>
      </section>
    </section>
    <section anchor="Cryptographic-processing" numbered="true" toc="default">
      <name>Cryptographic processing</name>
      <t>
  The outgoing packets MUST be protected exactly as in ESP transport
   mode <xref target="RFC4303"/>.  That is, the upper layer protocol packet is wrapped into
   an ESP header, encrypted, and authenticated exactly as if regular
   transport mode was used.  The resulting ESP packet is subject to IP
   header processing as defined in <xref target="IP-header-processing"/> and
	 <xref target="Handling-of-outgoing"/>.  The incoming ESP protected messages
	 are verified and decrypted exactly as if regular transport mode was used.
	 The resulting clear text packet is subject to IP header processing as
	 defined in <xref target="IP-header-processing"/> and <xref target="Handling-of-incoming"/>
        </t>
    </section>
    <section anchor="IP-header-processing" numbered="true" toc="default">
      <name>IP header processing</name>
      <t>
           The biggest difference between the BEET mode and the other two modes
   is in IP header processing.  In the regular transport mode the IP
   header is kept intact.  In the regular tunnel mode an outer IP header
   is created on output and discarded on input.  In the BEET mode the IP
   header is replaced with another one on both input and output.

   On the BEET mode output side, the IP header processing MUST first
   ensure that the IP addresses in the original IP header contain the
   inner addresses as specified in the SA.  This MAY be ensured by
   proper policy processing, and it is possible that no checks are
   needed at the SA processing time.  Once the IP header has been
   verified to contain the right IP inner addresses, it is discarded.  A
   new IP header is created, using the discarded inner header as a hint
   for other fields but the IP addresses.  The IP addresses in the new
   header MUST be the outer tunnel addresses.
   On input side, the received IP header is simply discarded.  Since the
   packet has been decrypted and verified, no further checks are
   necessary.  A new IP header, corresponding to a tunnel mode inner
   header, is created, using the discarded outer header as a hint for
   other fields but the IP addresses.  The IP addresses in the new
   header MUST be the inner addresses.

   As the outer header fields are used as hint for creating inner
   header, it must be noted that inner header differs as compared to
   tunnel-mode inner header.  In BEET mode the inner header will have
   the TTL, DF-bit and other option values from the outer header.  The
   TTL, DF-bit and other option values of the inner header MUST be
   processed by the stack.
        </t>
    </section>
    <section anchor="Handling-of-outgoing" numbered="true" toc="default">
      <name>Handling of outgoing packets</name>
      <t>
           The outgoing BEET mode packets are processed as follows:
       </t>
      <ul>
        <li>
       The system MUST verify that the IP header contains the inner
       source and destination addresses, exactly as defined in the SA.
       This verification MAY be explicit, or it MAY be implicit, for
       example, as a result of prior policy processing.  Note that in
       some implementations there may be no real IP header at this time
       but the source and destination addresses may be carried out-of-
       band.  In case the source address is still unassigned, it SHOULD
       be ensured that the designated inner source address would be
       selected at a later stage.
    </li>
        <li>
       The IP payload (the contents of the packet beyond the IP header)
       is wrapped into an ESP header as defined in <xref target="RFC4303"/> Section 3.3.
    </li>
        <li>
       A new IP header is constructed, replacing the original one.  The
       new IP header MUST contain the outer source and destination
       addresses, as defined in the SA.  Note that in some
       implementations there may be no real IP header at this time but
       the source and destination addresses may be carried out-of-band.
       In the case where the source address must be left unassigned, it
       SHOULD be made sure that the right source address is selected at
       a later stage.  Other than the addresses, it is RECOMMENDED that
       the new IP header copies the fields from the original IP header.
    </li>
        <li>
       If there are any IPv4 options in the original packet, it is
       RECOMMENDED that they are discarded.  If the inner header
       contains one or more options that need to be transported between
       the tunnel end-points, sender MUST encapsulate the options as
       defined in <xref target="IPv4-options"/>
    </li>
      </ul>
      <t>
   Instead of literally discarding the IP header and constructing a new    one,
   a conforming implementation MAY simply replace the addresses in
   an existing header.  However, if the RECOMMENDED feature of allowing
   the inner and outer addresses from different address families is
   used, this simple strategy does not work.
  </t>
    </section>
    <section anchor="Handling-of-incoming" numbered="true" toc="default">
      <name>Handling of incoming packets</name>
      <t>
   The incoming BEET mode packets are processed as follows: </t>
      <ol>
        <li>
       The system MUST verify and decrypt the incoming packet
       successfully, as defined in <xref target="RFC4303"/> section 3.4.  If the verification
       or decryption fails, the packet MUST be discarded. </li>
        <li>
       The original IP header is simply discarded, without any checks.
       Since the ESP verification succeeded, the packet can be safely
       assumed to have arrived from the right sender. </li>
        <li>
        A new IP header is constructed, replacing the original one.  The
       new IP header MUST contain the inner source and destination
       addresses, as defined in the SA.  If the sender has set the ESP
       next protocol field to 94 and included the Pseudo-Header(PH) as
       described in <xref target="IPv4-options"/>, the receiver MUST include the options
       after the constructed IP header.  Note, that in some
       implementations the real IP header may have already been
       discarded and the source and destination addresses are carried
       out-of-band.  In such case the out-of-band addresses MUST be the
       inner addresses.  Other than the addresses, it is RECOMMENDED
       that the new IP header copies the fields from the original IP
       header. </li>
      </ol>
      <t>
   Instead of literally discarding the IP header and constructing a new
   one a conforming implementation MAY simply replace the addresses in
   an existing header.  However, if the RECOMMENDED feature of allowing
   the inner and outer addresses from different address families is
   used, this simple strategy does not work.
      </t>
    </section>
    <section anchor="IPv4-options" numbered="true" toc="default">
      <name>IPv4 options handling</name>
      <t>
   In BEET mode, if IPv4 options or IPv6 options are transported inside
	 the tunnel, the sender MUST include a Pseudo Header after ESP header.
	 The pseudo-header identifies that IPv4 or IPv6 options from the original
	 packet are to be applied on the packet on input side.

   The sender MUST set the next protocol field on the ESP header as 94.
   The resulting pseudo header including the IPv4 options MUST be padded
   to 8 octet boundary.  The padding length is expressed in octets,
   valid padding lengths are 0 or 4 octets as the original IPv4 options
   are already padded to 4 octet boundary.  The padding MUST be filled
   with NOP options as defined in Internet Protocol [1] section 3.1
   Internet header format.  The padding is added in front of the
   original options to ensure that the receiver is able to reconstruct
   the original IPv4 datagram.  The Header Length field contains the
   length of the IPv4 options, and padding in 8 octets units.
   </t>
      <t>
   The receiver MUST remove this pseudo-header and padding as a part of
   BEET processing, in order reconstruct the original IPv4 datagram.
   The IPv4 options included into the pseudo-header MUST be added after
   the reconstructed IPv4 (inner) header on the receiving side.
   </t>
    </section>
    <section anchor="IPv4Frag" numbered="true" toc="default">
      <name>IPv4 Inner Fragments</name>
      <t>
    When inner IPv4 datagram is a fragment (as specified by the "more-fragments" flag being set to one <xref target="RFC791"/> or non-first fragment), this flag MUST NOT be copied to the outer ESP datagram header. Additionally, for any non-first fragment with a "more-fragments" flag or "fragment offset field", these two fields MUST NOT be copied to the outer IPv4 header of the ESP datagram.
		Here are a few possible ways to deal with these IPv4 fragments.
			</t>
      <ol>
        <li>
          <t>Re-assemble the IPv4 fragments, send to ESP and ESP datagram may fragmented.</t>
        </li>
        <li>
          <t>Drop the IPv4 fragments i.e. BEET mode does MAY not support IPv4 fragments</t>
          <ul>
            <li>
              <t>Copy the fragment flag, and offset length from inner IPv4 header to BEET pseudo-header <xref target="IPv4-options"/>.</t>
            </li>
            <li>
              <t>copy the complete inner IP header before the pseudo-header <xref target="IPv4-options"/></t>
            </li>
          </ul>
        </li>
        <li>
          <t>Other solutions? [TBD?]</t>
        </li>
      </ol>
      <t> TBD Discuss/Decide which of the above options make sense. </t>
    </section>
    <section anchor="IPv6Frag" numbered="true" toc="default">
      <name>IPv6 inner Fragments</name>
      <t>
    It's crucial to highlight that IPv6, use different fragmentation information in a distinct manner than IPv4 <xref target="RFC8200"/> Section 4.5. Specifically, an IPv6 fragment uses an optional header for fragments. Given its optional nature, the BEET mode can insert a pseudo-header with the value "94" and encapsulate all optional headers within the BEET datagram <xref target="IPv4-options"/>.
     </t>
    </section>
    <section anchor="IPv4IPv6" numbered="true" toc="default">
      <name>Mixed family IPv4 inside and IPv6 outside</name>
      <t>
				The inner datagram's IP version MUST be independent of outer IP version. The inner address family and address is taken from the negotiated Traffic Selectors.
        </t>
    </section>
    <section anchor="Policy-Considerations" numbered="true" toc="default">
      <name>Policy Considerations</name>
      <t>
	 In this section we describe how the BEET mode affects on IPsec policy
   processing.  This section is normative.

   A BEET Security Association SHOULD NOT be used with NULL
   authentication.

	 On the output side, the IPsec policy processing mechanism SHOULD take
   care that only packets with IP addresses matching with the inner
   addresses of a Security Association are passed to that Security
   Association.  If the policy mechanism do not provide full assurance
   on this, the SA processing MUST check the addresses.  Further policy
   distinction may be specified based on IP version, upper layer
   protocol, and ports.  If such restrictions are defined, they MUST be
   enforced.

	 On the output side, the policy rules SHOULD prevent any packets
   containing the inner IP addresses pair from escaping to the wire in
   clear text.

	 On the input side, there is no policy processing necessary on
   encrypted packets.  The SA is found based on the SPI and destination
   address.  A single SA MAY be associated with several destination
   addresses.  Since the outer IPsec addresses are discarded, and since
   the packet authenticity and integrity is protected by ESP, there is
   no need to check the outer addresses.  Since the inner addresses are
   fixed and restored from the SA, there is no need to check them.
   There MAY be further policy rules specifying allowed upper layer
   protocols and ports. If such restrictions are defined, they MUST be
   enforced.

	 On the input side, there SHOULD be a policy rule that filters out
   clear text packets that contain the inner addresses.
			</t>
    </section>
    <section anchor="Security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t> In this section we discuss the security properties of the BEET mode,
   discussing some limitations <xref target="RFC3552"/>.
		 </t>
      <t>There are no known new vulnerabilities that the introduction of the
   BEET mode would create.</t>
      <t>
   It is currently possible to implement the equivalent of BEET mode by
   using transport mode ESP and explicit network address translation at
   the end-hosts themselves.  However, such an implementation is more
   complex, less flexible, and potentially more vulnerable to security
   problems that are caused by misconfigurations; see Section 9. </t>
      <t>
   The main security benefit is an operational one.  To implement the
   same functionality without the BEET mode typically requires
   configuring three different, unrelated components in the hosts.  </t>
      <ul>
        <li> The transport mode ESP SAs must be configured. </li>
        <li> A host based NAT function must be configured to properly translate
      between the inner and outer addresses. </li>
        <li> A host firewall must be configured to properly filter out packets
      so that inner addresses do not leak in or out. </li>
      </ul>
      <t>
   While it may be possible to configure these components to achieve the
   same functionality, such a configuration is error prone, increasing
   the probability of security vulnerabilities.  An integrated BEET mode
   implementation is less prone to configuration mistakes.  Furthermore,
   it would be fairly hard to implement portable key management
   protocols that would be able to configure all of the required
   components at the same time.  On the other hand, it would be easy to
   provide a portable key management protocol implementation that would
   be able to configure BEET mode SAs through the specified PF_KEY
   extensions.</t>
      <t>
   Since the BEET security associations have the semantics of a fixed,
   point-to-point tunnel between two IP addresses, it is possible to
   place one or both of the tunnel end points into other nodes but those
   that actually "possess" the inner IP addresses, i.e., to implement a
   BEET mode proxy.  However, since such usage defeats the security
   benefits of combined ESP and hostNAT processing, as discussed above,
   the implementations SHOULD NOT support such usage. </t>
      <t>
   As in the BEET mode the outer header source address is not checked at
   the input handling, there is the potential possibility a DoS attack
   where the attacker sends random packets that match with the SPI of
   some BEET mode SA.  This kind of attack would cause the victim to
   perform unnecessary integrity checks that would result in a failure.
   If this kind of behavior is detected, the node may request rekeying
   from the Key Management Protocol, and after rekeying, if the attacker
   was not on the path, the new SPI value would not be known by the
   attacker.
	 </t>
    </section>
    <section anchor="IKENegotiation" numbered="true" toc="default">
      <name>IKEv2 Negotiation</name>
      <t>
			When negotiating a Child SA using using IKEv2, the initiator may use the new "USE_BEETMODE"
			Notification, to request a child SA pair with BEET mode support.
			The method used is similar to how USE_TRANSPORT_MODE is negotiated, as
			described in <xref target="RFC7296"/>
			</t>
      <t>
   To request a BEET mode SA on the Child SA pair,
   the initiator MUST include the USE_BEET_MODE notification when
   requesting a new Child SA (either during the initial IKE_AUTH or
   during CREATE_CHILD_SA exchanges). If the request is accepted then
   the response MUST also include a USE_BEET_MODE notification in its response.
   If the responder declines, does not include USE_BEET_MODE notification in the response,
	 the child SA will be established without BEET mode enabled.  If this is
   unacceptable to the initiator, the initiator MUST delete the child SA.
	 </t>
      <section title="USE_BEET_MODE Notify Message Payload" anchor="USEBeetNotify">
        <figure align="center">
          <artwork align="left"><![CDATA[
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-----------------------------+-------------------------------+
! Next Payload  !C!  RESERVED   !         Payload Length        !
+---------------+---------------+-------------------------------+
!  Protocol ID  !   SPI Size    !      Notify Message Type      !
+---------------+---------------+-------------------------------+
				 ]]></artwork>
        </figure>
        <ul>
          <li>Protocol ID (1 octet) - MUST be 0. MUST be ignored if not 0.</li>
          <li>SPI Size (1 octet) - MUST be 0. MUST be ignored if not 0.</li>
        </ul>
        <t> If initiator and the responder MUST not add USE_TRANSPORT_MODE and USE_BEET in the same request. </t>
      </section>
    </section>
    <section anchor="IANA" title="IANA Considerations">
      <t>
        This document defines a new IKEv2 Notify Message Type payloads for the IANA "IKEv2 Notify Message Types - Status Types" registry.
        </t>
      <figure align="center" anchor="iana_requests_i">
        <artwork align="left"><![CDATA[
      Value   Notify Type Messages - Status Types    Reference
      -----   ------------------------------    ---------------
      [TBD1]   USE_BEET_MODE                      [this document]
            ]]></artwork>
      </figure>
    </section>
    <section anchor="Implementation" numbered="true" toc="default">
      <name>Implementation Status</name>
      <t>
	 [Note to RFC Editor: Please remove this section and the reference to
      <xref target="RFC6982"/> before publication.]
	    </t>
      <t>
      This section records the status of known implementations of the
      protocol defined by this specification at the time of posting of
      this Internet-Draft, and is based on a proposal described in
      <xref target="RFC7942"/>. The description of implementations in this
      section is intended to assist the IETF in its decision processes
      in progressing drafts to RFCs. Please note that the listing of
      any individual implementation here does not imply endorsement
      by the IETF. Furthermore, no effort has been spent to verify the
      information presented here that was supplied by IETF contributors.
      This is not intended as, and must not be construed to be, a catalog
      of available implementations or their features. Readers are advised
      to note that other implementations may exist.
     </t>
      <t>
      According to <xref target="RFC7942"/>, "this will allow reviewers
      and working groups to assign due consideration to documents that
      have the benefit of running code, which may serve as evidence of
      valuable experimentation and feedback that have made the implemented
      protocols more mature.  It is up to the individual working groups
      to use this information as they see fit".
     </t>
      <t>
      Authors are requested to add a note to the RFC Editor at the
      top of this section, advising the Editor to remove the entire
      section before publication, as well as the reference to <xref target="RFC7942"/>.
     </t>
      <section anchor="impl-status.Linux.xfrm" title="Linux XFRM">
        <t> Linux </t>
        <dl>
          <dt> Organization: </dt>
          <dd> Linux kernel Project</dd>
          <dt> Name: </dt>
          <dd> Linux Kernel  https://www.kernel.org/</dd>
          <dt> Description: </dt>
          <dd> Implements BEET mode in ESP. The initial support was added in 2006. It is widely used </dd>
          <dt> Level of maturity: </dt>
          <dd> Stable</dd>
          <dt> Licensing: </dt>
          <dd> GPLv2</dd>
          <dt> Implementation experience: </dt>
          <dd> There is no support for IPv4 fragments yet. IPv6 fragments
						appears to work because the stack is not processing IPv6 Optional
						headers </dd>
          <dt> Contact: </dt>
          <dd> https://lore.kernel.org/netdev/ </dd>
        </dl>
      </section>
      <section anchor="section.impl-status.strongswan" title="strongSwan">
        <dl>
          <dt> Organization: </dt>
          <dd> The strongSwan Project</dd>
          <dt> Name: </dt>
          <dd> strongSwan https://docs.strongswan.org/docs/5.9/swanctl/swanctlConf.html </dd>
          <dt> Description: </dt>
          <dd> Implement IKE negotiation and and ESP support for BEET mode on Linux.</dd>
          <dt> Level of maturity: </dt>
          <dd> Stable</dd>
          <dt> Coverage: </dt>
          <dd> Implements negotiating BEET mode support in Child SA negotiations  and using it in ESP. The initial support was added in 2006 </dd>
          <dt> Licensing: </dt>
          <dd> GPLv2</dd>
          <dt> Implementation experience </dt>
          <dd>
             strongSwan use a private space notification value for IKE negotiation.
             USE_BEET_MODE (40961).
            </dd>
          <dt> Contact </dt>
          <dd>Tobias Brunner tobias@strongswan.org</dd>
        </dl>
      </section>
      <section anchor="section.impl-status.iproute2" title="iproute2">
        <dl>
          <dt> Organization: </dt>
          <dd> The iproute2 Project</dd>
          <dt> Name: </dt>
          <dd> iproute2 https://git.kernel.org/pub/scm/network/iproute2/iproute2.git</dd>
          <dt> Description: </dt>
          <dd> Implements BEET mode support in ESP. e.g. command support "ip xfrm policy ... mode beet" . and "ip xfrm state .. mode beet". The initial support was added in 2006</dd>
          <dt> Level of maturity: </dt>
          <dd> Stable</dd>
          <dt> Licensing: </dt>
          <dd> GPLv2</dd>
          <dt> Implementation experience: </dt>
          <dd> TBD</dd>
          <dt> Contact: </dt>
          <dd> https://lore.kernel.org/netdev/ or Stephen Hemminger stephen@networkplumber.org </dd>
        </dl>
      </section>
    </section>
    <section anchor="Acknowledgements" numbered="true" toc="default">
      <name>Acknowledgments</name>
      <t>
			[TBD] If Pekka and Jan would like to be the Co-authers I would gladly add them. Currently I am trying reach out to them, via Tero, and ask their permission to take over the expired  draft-nikander-esp-beet-mode-09. If they choose to be not be Co-authors add a detailed acknowledgment for the previous work. </t>
      <t>The authors would like to thank previous by Pekka Nikander and Jan Melen, for the earlier Internet Draft of BEET mode. This work is based on their work </t>
      <t> TBD the original draft  Acknowledge few more people. May be copy them over. Lets wait to reach out Pekka Nikander. </t>
    </section>
  </middle>
  <back>
    <references>
      <name>Normative References</name>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2401.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4303.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7296.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.791.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8200.xml"/>
    </references>
    <references>
      <name>Informative References</name>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6982.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7942.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5201.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5202.xml"/>
      <xi:include href="https://datatracker.ietf.org/doc/bibxml3/draft-nikander-esp-beet-mode-09.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9333.xml"/>
    </references>
    <section anchor="app-additional" numbered="true" toc="default">
      <name>Additional Stuff</name>
      <t>This becomes an Appendix.</t>
    </section>
  </back>
</rfc>
