<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- <xi:strict="yes" ?>
<xi:compact="yes" ?>
<xi:subcompact="no" ?>  -->
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std" docName="draft-antony-ipsecme-beet-mode-00" ipr="trust200902" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" tocDepth="4" symRefs="true" sortRefs="true" version="3" consensus="true">
  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->
    <title abbrev="BEET mode for ESP">A Bound End-to-End Tunnel (BEET) mode for ESP </title>
    <!-- add 'role="editor"' below for the editors if appropriate -->
    <!-- Another author who claims to be an editor -->
    <author fullname="Antony Antony" initials="A." surname="Antony">
      <organization abbrev="secunet">secunet Security Networks AG</organization>
      <address>
        <email>antony.antony@secunet.com</email>
      </address>
    </author>
    <author fullname="Steffen Klassert" initials="S." surname="Klassert">
      <organization abbrev="secunet">secunet Security Networks AG</organization>
      <address>
        <email>steffen.klassert@secunet.com</email>
      </address>
    </author>
    <area>sec</area>
    <workgroup>IPSECME Working Group</workgroup>
    <keyword>IKEv2</keyword>
    <keyword>BEET</keyword>
    <abstract>
      <t>
   This document describes IPsec ESP, known as Bound End-to-End Tunnel (BEET)
   protocol.

	 This document replaces and updates RFC 5996, and includes all
   of the errata for it, and it is intended to update IKEv2 to be
   Internet Standard.


	 IKE is a component of IPsec used for performing mutual



   authentication and establishing and maintaining Security Associations
   (SAs).  This document replaces and updates RFC 5996, and includes all
   of the errata for it, and it is intended to update IKEv2 to be
   Internet Standard.


    This document specifies a new mode for IPsec ESP, known as Bound
		End-to-End Tunnel (BEET) mode. This mode complements the existing ESP tunnel
		and transport modes, while enhancing end-to-end IPsec usage. It offers the
		characteristics of the tunnel mode but without its usual overhead. The BEET
		mode is designed to accommodate evolving applications of ESP, such as
		minimalist end-to-end tunnel, mobility and multi-address multi-homing.
		Additionally, this document proposes a new Notify Message, USE_BEET_MODE, for the
		Internet Key Exchange Protocol Version 2 (IKEv2) specified in
		<xref target="RFC7296"/>, to facilitate BEET mode Security Association
		negotiation.
    </t>
    </abstract>
  </front>
  <middle>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <t>
   The current IPsec ESP specification <xref target="RFC4303"/> defines two
	 modes of operation: the tunnel mode and the transport mode.  The tunnel mode is mainly
   intended for non-end-to-end use where one or both of the ends of the
   ESP Security Associations (SAs) are located in security gateways,
   separate from the actual IPsec end-nodes.  The transport mode is intended
   for end-to-end use, where both ends of the Security Association are
   terminated at the end-nodes themselves.

   This document defines a new mode for ESP, called Bound End-to-End
   Tunnel (BEET) mode.  The purpose of the BEET mode is to provide limited
   tunnel mode semantics without the overhead associated with the
   regular tunnel mode.  As the name states, the BEET mode is intended
   solely for end-to-end use.  It provides tunnel mode semantics in the
   sense that the IP addresses seen by the applications and the IP
   addresses used on the wire are distinct from each other, providing
   the illusion that the application-level IP addresses are tunneled
   over the network-level IP addresses.  However, the BEET mode does not
   support full tunnel semantics.  More specifically, the IP addresses as seen
	 by the application are strictly bound. In BEET mode, only a pair of addresses
	 is negotiated, and only this pair of strictly bound inner addresses MUST be
	 used within a given BEET mode Security Association. This is in contrast to
	 the regular tunnel mode, where an IP address range, source range and
	 destination range, can be negotiated, and the inner IP addresses can be any
	 pair of IP addresses within the negotiated IP address range.

   A BEET mode Security Association records two pairs of IP addresses,
   called inner addresses and outer addresses. The inner addresses are
   what the applications see.  The outer addresses are what appears on
   the wire.  Since the inner addresses are fixed for the lifetime of
   the Security Association, they need not be sent in each
   packet.  Instead, they are set up as the Security Associations are
   created, they are verified when packets are sent, and they are
   restored as packets are received.

   This all gives BEET mode the efficiency of transport mode with a
   limited set of end-to-end tunnel semantics. The increase efficiency is
   accomplished by removing the inner IP header from the packet that is
   transported on the wire. Due to this removal of the inner IP header, the TTL
   of a tunneled packet is reduced at every router on the path as the TTL
   value is copied from inner to outer header by the sender and vice
   versa by the receiver.  The semantics of BEET mode is limited in the
   sense that only one fixed pair of inner addresses is allowed.  The
   outer addresses may change over the lifetime of the SA, but the
   inner addresses cannot.  If a new pair of inner addresses is needed,
   a new BEET mode Security Association must be established.
	 In the cases considered here, a single pair of security associations between any
	 single pair of nodes is usually sufficient.
      </t>
      <section numbered="true" toc="default">
        <name>Requirements Language</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
       "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
       document are to be interpreted as described in
			 <xref target="RFC2119" format="default">RFC 2119</xref>.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Terminology</name>
        <t>
       In this section we define terms specific to this document. This section
			 is normative.
				</t>
        <ul>
          <li> Inner IP address :
      An IP address as seen by applications, typically stored in TCP or other
      upper layer data structures. It is processed by the IP stack prior
      to ESP processing in the output side and after ESP processing in
      the input side.
			</li>
          <li>
      Outer IP address: An IP address seen on the wire and processed by the IP
			stack after ESP processing in the output side and before ESP processing
			in the input side.
					</li>
          <li>
      Inner IP header: An IP header that contains inner IP addresses.  In some cases an
      inner IP header may be represented as an internal data structure
      containing data equivalent to an IP header.</li>
          <li>
      Outer IP header: An IP header that contains outer IP addresses.  In some cases an
      outer IP header may be represented as an internal data structure
      containing the data equivalent to an IP header.  </li>
        </ul>
      </section>
    </section>
    <section anchor="Background" numbered="true" toc="default">
      <name>Background</name>
      <t>
For years, the idea of a minimal IPsec tunnel mode for end-to-end security has
sparked discussions and innovation. BEET mode has been in use for over a decade.
It hs the potential to improve secure data transmission. Once BEET mode is
standardized its potential for enhancing secure communications would increase
with interoperablity. </t>
      <section anchor="Related" numbered="true" toc="default">
        <name>Related work</name>
        <t>
  The basic idea captured by this draft has been floating around for a
  long time. Steven Bellovin's HostNAT talk [8] and at the Los Angeles IETF
  is an early example, and this ID is based on BEET mode ID
  <xref target="I-D.nikander-esp-beet-mode"/>. The same idea has surfaced
  several times. Perhaps the most concrete current proposal is the Host
  Identity Protocol (HIP) <xref target="RFC5201"/> and <xref target="RFC5202"/>
  where BEET-mode ESP processing is an integral part of the overall protocol
  without IKE negotiation. The updated version of the Host Identity Protocol
  (HIPv2) <xref target="RFC7401"/> and <xref target="RFC7402"/> recommend the
  use of BEET mode.
</t>
        <t>
	Minimal ESP <xref target="RFC9333"/> can also benefit from the use BEET mode.
  It reduces the outter packet size by 20 - 40 bytes per packet, by ommiting
	inner IPv4/IPv6 header, compared to tunnel mode.
	However <xref target="RFC9333"/> did not recommend the use of BEET mode, as
	it is not yet standardized
 </t>
      </section>
    </section>
    <section anchor="Use" numbered="true" toc="default">
      <name>Use scenarios</name>
      <t>
  In this section we describe a number of possible use scenarios. None of
  these scenarios are meant to be complete specifications on how exactly
  to support the functionality. Separate specifications are needed for
  that. Instead, the purpose of this section is to discuss the overall
  benefits of BEET mode, and to lay out a road map for possible future
  documents. This section is informative.
       </t>
      <section anchor="IPsec-minimal" numbered="true" toc="default">
        <name>Minimal IPsec for end-to-end</name>
        <t>
Over the years, BEET-mode has been widely adopted as a minimal IPsec tunnel
for end-to-end scenarios, effectively reducing data transmission over
the wire. It also helps alleviate MTU issues.
Additionally, BEET is valuable for low-power devices, as it reduces
power consumption <xref target="RFC9333"/> and complexity. In situations where devices
or IPsec connections are dedicated to a single application or transport protocol,
BEET mode simplifies packet processing and conserves energy, especially for
lower-powered devices.
</t>
      </section>
      <section anchor="NAT-T" numbered="true" toc="default">
        <name>NAT traversal</name>
        <t>
   NAT traversal is currently a major issue in IPsec. Encapsulating packets into
	 UDP using
   Transport mode may suffice in some cases, but it becomes inadequate when
	 multiple clients are behind a NAT gateway. In such situations, tunnel mode
	 becomes necessary. </t>
        <t>
   BEET mode offers tunnel mode semantics without the additional packet overhead
	 associated with traditional tunnel mode when operating behind a NAT gateway.
	 A pair of BEET-mode Security Associations (SAs) can effectively "un-NAT"
	 packets originationg from behind a NAT gatewa as they traverse the network.
	 [AA do we need this ?? This process is illustrated in Figure 1.]
   </t>
        <t> [SK: The figure and the comments from the old draft is missing here.
   Is the scenario where a client behind NAT knows it's public address
   common? Maybe ask Pablo.]</t>
      </section>
      <section anchor="End-node-multihome" numbered="true" toc="default">
        <name>End-node multi-address multi-homing</name>
        <t>
   BEET mode enables limited end-node multi-address multi-homing. It
   establishes a tunnel between end-hosts with fixed inner IP addresses,
   allowing multi-homed hosts to use different outer IP addresses in
   various packets without impacting upper-layer protocols.

   Upper-layer protocols consistently see the inner IP address, ensuring
   seamless communication over fixed IP addresses.
</t>
        <t>

   Implementing this kind of limited multi-homing support would require
   a small change to the current IPsec SPD and SA implementations.
   Currently the incoming SA selection is based on the SPI and
   destination address, with the implicit assumption that there is only
   one possible destination address for each incoming SA.  In a multi-
   homed host it would be desirable to have multiple destination
   addresses associated with the SA, thereby allowing the same SA to be
   used independent on the actual destination address in the packets.
   Removing the destination address from unicast SA lookup is already
   being proposed in the current ESP <xref target="RFC4303"/>. [AA verify this part]

	 </t>
      </section>
    </section>
    <section anchor="Protocol-definition" numbered="true" toc="default">
      <name>Protocol Definition</name>
      <t>
   In this section we define the exact protocol formats and operations. This section is normative.
   </t>
      <section anchor="Changes-SA" numbered="true" toc="default">
        <name>Changes to Security Association data structure</name>
        <t>
   A BEET mode Security Association contains the same data as a regular
   tunnel mode Security Association, with the exception that the inner
   selectors must be single addresses and cannot be subnets.  The data
   includes the following: </t>
        <ul>
          <li> A pair of inner IP addresses.</li>
          <li> A pair of outer IP addresses. </li>
          <li> Cryptographic keys and other data as defined in <xref target="RFC4301"/> Section 4.4.2. </li>
        </ul>
        <t> A conforming implementation MAY store the data in a way similar to a
   regular tunnel mode Security Association. </t>
        <t>
   Note that in a conforming implementation, the inner and outer
   addresses MAY belong to different address families. All
   implementations that support both IPv4 and IPv6 SHOULD support both
   IPv4-over-IPv6 and IPv6-over-IPv4 tunneling.
   </t>
      </section>
      <section anchor="Packet-format" numbered="true" toc="default">
        <name>Packet format</name>
        <t>
   The wire packet format is identical to the ESP transport mode wire
   format as defined in  <xref target="RFC4303"/> Section 3.1.1.  However,
	 the resulting packet contains outer IP addresses instead of the inner IP addresses
   received from the upper layer.  The construction of the outer headers
   is defined in <xref target="RFC4301"/> Section 5.1.2.  The following diagrams
   illustrates ESP BEET mode positioning for typical IPv4 and IPv6
   packets. </t>
        <t>[SK: The figures are not consistent. Let's discuss this in a call.
   Why is dest opts. in IPv6 encrypted, but other ext hdrs are not?</t>
      </section>
      <section anchor="InnerIPv4" numbered="true" toc="default">
        <name>Inner IPv4 Datagram</name>
        <figure anchor="inneripv4before" align="center">
          <name>IPv4 INNER DATAGRAM BEFORE APPLYING ESP</name>
          <artwork align="left"><![CDATA[
    +-----------------------------+
    | inner IP hdr  | TCP | Data  |
    +-----------------------------+
		     ]]></artwork>
        </figure>
        <figure align="center" anchor="afterespouteripv4">
          <name> AFTER APPLYING ESP, OUTER v4 ADDRESSES </name>
          <artwork align="left"><![CDATA[
    +--------------------------------------------------+
    | outer IP hdr  |     |     |      |   ESP   | ESP |
    | (any options) | ESP | TCP | Data | Trailer | ICV |
    +--------------------------------------------------+
                          |<---- encryption ---->|
                    |<-------- integrity ------->|
				]]></artwork>
        </figure>
        <figure align="center" anchor="afterespouteripv6">
          <name>AFTER APPLYING ESP, OUTER v6 ADDRESSES</name>
          <artwork align="left"><![CDATA[
    +------------------------------------------------------+
    | outer    | new ext |     |     |      |  ESP   | ESP |
    | IPv6 hdr | hdrs.   | ESP | TCP | Data | Trailer| ICV |
    +------------------------------------------------------+
                               |<--- encryption ---->|
                         |<------ integrity -------->|
				]]></artwork>
        </figure>
        <figure align="center" anchor="ipv4inneroptions">
          <name>IPv4 INNER DATAGRAM with IP options BEFORE APPLYING ESP</name>
          <artwork align="left"><![CDATA[
    +----------------------------+
    | inner IP hdr  |     |      |
    |  + options    | TCP | Data |
    +----------------------------+
				]]></artwork>
        </figure>
        <figure align="center" anchor="ipv4outeroptions">
          <name>IPv4 AFTER APPLYING ESP, OUTER v4 ADDRESSES INNER IPv4 OPTIONS </name>
          <artwork align="left"><![CDATA[
    +------------------------------------------------------------+
    | outer IP hdr  |     | PH      |     |      |   ESP   | ESP |
    | (any options) | ESP | Options | TCP | Data | Trailer | ICV |
    +------------------------------------------------------------+
                          |<------- encryption ----------->|
                    |<----------- integrity -------------->|
                        PH = BEET mode Pseudo-Header
        ]]></artwork>
        </figure>
        <figure align="center" anchor="ipv6outeroptions">
          <name>IPv4 + OPTIONS AFTER APPLYING ESP, OUTER IPv6 ADDRESSES </name>
          <artwork align="left"><![CDATA[

    +---------------------------------------------------------------+
    | outer  | new ext |     | PH       |     |      |  ESP   | ESP |
    | IP hdr | hdrs.   | ESP | Options  | TCP | Data | Trailer| ICV |
    +---------------------------------------------------------------+
                             |<------ encryption ------------>|
                       |<---------- integrity --------------->|

                               PH = BEET mode Pseudo-Header

        ]]></artwork>
        </figure>
      </section>
      <section anchor="InnerIPv6" numbered="true" toc="default">
        <name>Inner IPv6 Datagram</name>
        <figure align="center" anchor="ipv6beforeesp">
          <name> IPv6 DATAGRAM BEFORE APPLYING ESP </name>
          <artwork align="left"><![CDATA[
    +--------------------------------------+
    |                |  ext   |     |      |
    | inner IPv6 hdr |  hdrs  | TCP | Data |
    +--------------------------------------r+-
					]]></artwork>
        </figure>
        <figure align="center" anchor="ipv6afterespipv6">
          <name> IPv6 DATAGRAM AFTER APPLYING ESP, OUTER IPv6 ADDRESSES </name>
          <artwork align="left"><![CDATA[
    +--------------------------------------------------------------+
    | outer    | new ext |     | ext  |     |      |  ESP    | ESP |
    | IPv6 hdr | hdrs.   | ESP | hdrs | TCP | Data | Trailer | ICV |
    +--------------------------------------------------------------+
                               |<-------- encryption ------------->|
                         |<-------------- integrity -------------->|
					]]></artwork>
        </figure>
        <figure align="center" anchor="ipv6afterespipv4">
          <name> IPv6 DATAGRAM AFTER APPLYING ESP, OUTER IPv4 ADDRESSES </name>
          <artwork align="left"><![CDATA[
    ---------------------------------------------------
    | outer  |     | ext  |     |      |  ESP    | ESP |
    | IP hdr | ESP | hdrs.| TCP | Data | Trailer | ICV |
    ---------------------------------------------------
                   |<------- encryption -------->|
             |<----------- integrity ----------->|
					]]></artwork>
        </figure>
      </section>
    </section>
    <section anchor="Cryptographic-processing" numbered="true" toc="default">
      <name>Cryptographic processing</name>
      <t>
  The outgoing packets MUST be protected exactly as in ESP transport
   mode <xref target="RFC4303"/>.  That is, the upper layer protocol packet is wrapped into
   an ESP header, encrypted, and authenticated exactly as if regular
   transport mode was used.  The resulting ESP packet is subject to IP
   header processing as defined in <xref target="IP-header-processing"/> and
	 <xref target="Handling-of-outgoing"/>.  The incoming ESP protected messages
	 are verified and decrypted exactly as if regular transport mode was used.
	 The resulting cleartext packet is subject to IP header processing as
	 defined in <xref target="IP-header-processing"/> and <xref target="Handling-of-incoming"/>
        </t>
    </section>
    <section anchor="IP-header-processing" numbered="true" toc="default">
      <name>IP header processing</name>
      <t>
           The biggest difference between BEET mode and the other two modes
   lies in the way IP headers are processed.  In regular transport mode, the IP
   header is kept intact.  In the regular tunnel mode, an outer IP header
   is created on output and discarded on input.  In BEET mode, the IP
   header is replaced with another one on both input and output.
	 </t>
      <t>
	 On the BEET mode output side, the IP processing MUST first ensure that
  the IP addresses in the original IP header contain the inner addresses
  as specified in the SA. This MAY be ensured by proper policy processing,
  and it is possible that no checks are needed at the SA processing time.
  Once the IP header has been verified to contain the right IP inner
  addresses, it is discarded. A new IP header is derived, using the
  discarded inner header as a hint for other fields except the IP
  addresses, the IPv4 options, the IPv6 optional extensions,
	and the IPv4 fragmentation offset when the packet is a fragment.
	The IP addresses in the new header MUST be the outer tunnel addresses.
	</t>
      <t>

  On the input side, the received IP header is simply discarded. Since the
  packet has been decrypted and verified, no further checks are necessary.
  A new IP header, corresponding to a tunnel mode inner header, is derived,
  using the discarded outer header as a hint for other fields but the IP
  addresses, the IPv4 options, the IPv6 optional extensions, and the IPv4
  fragmentation offset when the packet is a fragment. The IP addresses in
  the new header MUST be the inner addresses negotiated.
	 </t>
      <t>
   As the outer header fields are used as a hint for creating the inner
   header, it must be noted that the BEET inner header differs from
   tunnel mode inner headers. In BEET mode, an inner header will contain
   the TTL, DF-bit and other option values from the outer header. The
   TTL, DF-bit and other option values of the inner header MUST be
   processed by the stack. [AA would we loose the DF value?? if IPsec gateway has different policy?
	 or is possible to restore the same as inner packet?]
        </t>
    </section>
    <section anchor="Handling-of-outgoing" numbered="true" toc="default">
      <name>Handling of outgoing packets</name>
      <t>
           The outgoing BEET mode packets are processed as follows:
       </t>
      <ul>
        <li>
       The system MUST verify that the IP header contains the inner
       source and destination addresses, exactly as defined in the SA.
       This verification MAY be explicit, or it MAY be implicit, for
       example, as a result of prior policy processing.  Note that in
       some implementations there may be no real IP header at this time,
       but the source and destination addresses may be carried out-of-
       band. In case the source address is still unassigned, it SHOULD
       be ensured that the designated inner source address would be
       selected at a later stage.
    </li>
        <li>
       The IP payload (the contents of the packet beyond the IP header)
       is wrapped into an ESP header as defined in <xref target="RFC4303"/> Section 3.3.
    </li>
        <li>
       A new IP header is constructed, replacing the original one.  The
       new IP header MUST contain the outer source and destination
       addresses, as defined in the SA.  Note that in some
       implementations there may be no real IP header at this time but
       the source and destination addresses may be carried out-of-band.
       In cases where the source address must be left unassigned, it
       SHOULD be ensured that the right source address is selected at
       a later stage. Other than the addresses, it is RECOMMENDED that
	     the new IP header copies the fields from the original IP header,
	     unless the packet is a IP fragment.
    </li>
        <li>
    If there are any IPv4 options in the original packet, they are copied into
    ESP payload. The IPv4 options are tunneled between the tunnel end-points.
    The sender MUST encapsulate the options as defined in
    <xref target="IPv4-ph"/>.
</li>
        <li>
 If the packet is an IPv4 fragment, the flags and the fragment
	    offset field from the inner IP packet MUST NOT be copied.
	    Instead these two fields MUST be encapsulated with a PH
	    header as defined in  <xref target="IPv4-ph"/>.
    </li>
      </ul>
      <t>
   Instead of literally discarding the IP header and constructing a new one,
   a conforming implementation MAY simply replace the addresses in an
   existing header. However, if the RECOMMENDED feature of allowing the inner
   and outer addresses from different address families is used, this simple
   strategy does not work.
   </t>
    </section>
    <section anchor="Handling-of-incoming" numbered="true" toc="default">
      <name>Handling of incoming packets</name>
      <t>
   The incoming BEET mode packets are processed as follows: </t>
      <ol>
        <li>
      The system MUST successfully verify and decrypt the incoming packet, as
			specified in <xref target="RFC4303"/> section 3.4.  If the verification
			or decryption fails, the packet MUST be discarded. </li>
        <li>
				The original IP header is discarded without further verification since
				the ESP verification has already confirmed the packet's integrity and source.
			 The packet can be safely assumed to have arrived from the right sender. </li>
        <li>
        A new IP header is constructed, replacing the original one.  The
       new IP header MUST contain the inner source and destination
       addresses, as defined in the SA.  If the sender has set the ESP
       next protocol field to 94 and included the Pseudo-Header as
       described in <xref target="IPv4-ph"/>, the receiver MUST include the options
       after the constructed IP header.  Note, that in some
       implementations the real IP header may have already been
       discarded and the source and destination addresses are carried
       out-of-band.  In such case the out-of-band addresses MUST be the
       inner addresses.  Other than the addresses, it is RECOMMENDED
       that the new IP header copies the fields from the original IP
       header. [AA how about ESP in UDP and mapping changes?]
			 </li>
      </ol>
      <t>
	Alternatively, a conforming implementation MAY replace the addresses in an
	 existing header rather than discarding it and creating a new one.
	 However, if the RECOMMENDED feature of allowing
   the inner and outer addresses from different address families is
   used, this simple strategy does not work.
      </t>
    </section>
    <section anchor="IPv4-ph" numbered="true" toc="default">
      <name>IPv4 Pseudo Header</name>
      <t>
   In BEET mode, if IPv4 options or IPv6 optional extensions are transported
	 inside the tunnel, as ESP payload. For IPv4, the sender MUST include a
	 Pseudo Header(PH) after ESP header.
	 The pseudo-headerr indicates the IPv4 packet has options or the fragmentation
	 flags and fragmentation offset is set.
	 </t>
      <t>
   The sender MUST set the next protocol field on the ESP header as 94.
   The resulting pseudo header including the IPv4 options,  MUST be padded
   to 8 octet boundary.  The padding length is expressed in octets,
   valid padding lengths are 0 or 4 octets as the original IPv4 options
   are already padded to 4 octet boundary.  The padding MUST be filled
   with NOP options as defined in Internet Protocol <xref target="RFC791"/>
	 section 3.1 Internet header format.  The padding is added in front of the
   original options to ensure that the receiver is able to reconstruct
   the original IPv4 datagram.  The Header Length field contains the
   length of the IPv4 options, and padding in 8 octets units.
   </t>
      <figure align="center" anchor="pseudoheader">
        <name> BEET mode pseudo header format </name>
        <artwork align="left"><![CDATA[
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  |   Header Len  |    Pad Len    |F = 2| Reserved|
   +---------------+---------------+-------------------------------+
   | IHF = 3 |Fragment offset (opt.) = 13 | PH padding             |
   +-----------------------------------------+---------------------+
   |                     IPv4 options (opt.) | Opt Padding         |
   +---------------------------------------------------------------+
	]]></artwork>
      </figure>
      <ul>
        <li>
          <t>
		Next Header - Identifies the data following this header.
			</t>
        </li>
        <li>
          <t>
		Header Len - 8-bit unsigned integer. Length of the pseudo header in
		8-octet units, including IHF and Fragment offset, IPv4 options, when present, not including the first 8 octets.
			</t>
        </li>
        <li>
          <t>
		Pad Len - 8-bits unsigned integer. Length of padding in octets, valid padding lengths are:
			</t>
          <ul>
            <li>
              <t>
						0, 4 : no IPv4 fragment and options are present [AA Note : old case]
						</t>
            </li>
            <li>
              <t>
						2, 6 : IPv4 fragment and no IPv4 options.
						</t>
            </li>
            <li>
              <t>
						2, 6 : IPv4 fragment and options.
						</t>
            </li>
          </ul>
        </li>
        <li>
          <t>
		F - 2 bits Flags. 00 IP options, 01 Fragment, 10 IP options and Fragment, 11 Reserved
				</t>
        </li>
        <li>
          <t>
		Reserved - Lower 6-bits, set to zero
			</t>
        </li>
        <li>
          <t>
		IHF - Flags from the inner IP header (optional) when F = 01 or 10
			</t>
        </li>
        <li>
          <t>
		Fragment offset 13 bits - Fragment offset from the inner IP header (optional) when F = 01 or 10
			</t>
        </li>
        <li>
          <t>
		Padding - 0, 2 or 4 octets of zeros, depending on the fragment flag.
			</t>
        </li>
        <li>
          <t>
		IPv4 options - IPv4 options from the inner IP header with optional padding. Alligned to 32 bits.
			</t>
        </li>
      </ul>
      <t>

  </t>
      <t>
  The receiver MUST remove this pseudo-header and padding as a part of BEET
  processing, in order to reconstruct the original IPv4 datagram. The IPv4
  options included in the pseudo-header MUST be added after the reconstructed
  IPv4 (inner) header on the receiving side. Also copy the flags and Fragment offset
	when the PH flags is 01, 10.
	</t>
      <t>
  Note: when the IPv4 options are present, the outer header's IHL would be
  different from the inner header IHL.
	</t>
      <t>
   The receiver MUST remove this pseudo-header and padding as a part of
   BEET processing, in order reconstruct the original IPv4 datagram.
   The IPv4 options included into the pseudo-header MUST be added after
   the reconstructed IPv4 (inner) header on the receiving side.
   </t>
      <t>
  Note: When the pseudo-header is present due to the presence of IPv4 options
  in the inner IP header, the outer header's IHL (Internet Header Length) would
  be different from the inner IP header IHL.
</t>
    </section>
    <section anchor="IPv4Frag" numbered="true" toc="default">
      <name>IPv4 Inner Fragments</name>
      <t>
  When the inner IPv4 datagram is a fragment (as specified by the
  "more-fragments" flag being set to one <xref target="RFC791"/>), this flag
  MUST NOT be copied to the outer ESP datagram header. Additionally, for any
  non-first fragment with a "more-fragments" flag or "fragment offset field,"
  these two fields MUST NOT be copied to the outer IPv4 header of the ESP
  datagram.
</t>
      <t>
  Here are a few possible ways to deal with these IPv4 fragments.
</t>
      <ol>
        <li>
    Re-assemble the IPv4 fragments, send to ESP, and ESP datagram may be
    fragmented as required.
  </li>
        <li>
    Drop the IPv4 fragments, i.e., BEET mode IPv4 support for fragments is
    optional.
  </li>
        <li>
    Copy the fragment flag and offset length from the inner IPv4 header to
    BEET pseudo-header <xref target="IPv4-ph"/>.
  </li>
        <li>
    Explore other solutions? [TBD?]
  </li>
      </ol>
      <t> TBD Discuss/Decide which of the above options make sense. </t>
    </section>
    <section anchor="IPv6Frag" numbered="true" toc="default">
      <name>IPv6 inner Fragments</name>
      <t>
  It's crucial to highlight that IPv6 uses fragmentation information in a
  distinct manner than IPv4 <xref target="RFC8200"/> Section 4.5.
  Specifically, an IPv6 fragment uses IPv6 optional extensions for
  fragments. BEET mode treats the IPv6 optional extensions as ESP payload and move from inner header to ESP payload.
     </t>
    </section>
    <section anchor="IPv4IPv6" numbered="true" toc="default">
      <name>Mixed family IPv4 inside and IPv6 outside</name>
      <t>
    The inner datagram's IP version MUST be independent of the outer IP
    version. The inner address family and address are taken from the
    negotiated Traffic Selectors. When the inner datagram contains IPv4
    with fragments or IPv4 options, use <xref target="IPv4-ph"/>.
  </t>
    </section>
    <section anchor="IPv6IPv4" numbered="true" toc="default">
      <name>Mixed family IPv6 inside and IPv4 outside</name>
      <t>
    When the inner datagram is an IPv6 datagram with IPv6 optional
    extensions, copy it into ESP payload <xref target="IPv6Frag"/>.
  </t>
    </section>
    <section anchor="Policy-Considerations" numbered="true" toc="default">
      <name>Policy Considerations</name>
      <t>
	 In this section we describe how BEET mode affects on IPsec policy
   processing.  This section is normative.
	 </t>
      <t>
   A BEET Security Association SHOULD NOT be used with NULL
   authentication.
	 </t>
      <t>
	 On the output side, the IPsec policy processing mechanism SHOULD take
   care that only packets with IP addresses matching the inner
   addresses of a Security Association are passed on to that Security
   Association.  If the policy mechanism does not provide full assurance
   on this point, the SA processing MUST check the addresses.  Further policy
   distinction may be specified based on IP version, upper layer
   protocol, and ports.  If such restrictions are defined, they MUST be
   enforced.
	 </t>
      <t>
	 On the output side, the policy rules SHOULD prevent any packets
   containing the pair of inner IP addresses from escaping to the wire in
   cleartext.
	 </t>
      <t>
	 On the input side,no policy processing is necessary for
   encrypted packets.  The SA is deduced from the SPI and destination
   address.  A single SA MAY be associated with several outter destination
   addresses.  Since the outer IPsec addresses are discarded, and since
   the packet authenticity and integrity are protected by ESP, there is
   no need to check the outer addresses.  Since the inner addresses are
   fixed and restored from the SA, there is no need to check them.
   There MAY be further policy rules specifying allowed upper layer
   protocols and ports. If such restrictions are defined, they MUST be
   enforced.
	 </t>
      <t>
	 On the input side, there SHOULD be a policy rule that filters out
   cleartext packets that contain the inner addresses.
			</t>
    </section>
    <section anchor="Security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t> In this section we discuss the security properties of the BEET mode,
   discussing some and point out some of its limitations <xref target="RFC3552"/>.
		 </t>
      <t>There are no known new vulnerabilities that the introduction of the
   BEET mode would create.</t>
      <t>
   It is currently possible to implement the equivalent of BEET mode by
   using transport mode ESP and explicit network address translation at
   the end-hosts themselves.  However, such an implementation is more
   complex, less flexible, and potentially more vulnerable to security
   problems that are caused by misconfigurations; see Section 9. </t>
      <t>
   The main security benefit is an operational one.  To implement the
   same functionality without BEET mode typically requires
   configuring three different, unrelated components in the hosts.  </t>
      <ul>
        <li> The transport mode ESP SAs must be configured. </li>
        <li> A host-based NAT function must be configured to properly translate
      between the inner and outer addresses. </li>
        <li> A host firewall must be configured to properly filter out packets
      so that inner addresses do not leak in or out. </li>
      </ul>
      <t>
   While it may be possible to configure these components to achieve the
   same functionality, such a configuration is error prone, increasing
   the probability of security vulnerabilities.  An integrated BEET mode
   implementation is less prone to configuration mistakes.  Furthermore,
   it would be fairly hard to implement portable key management
   protocols that would be able to configure all of the required
   components at the same time.  On the other hand, it would be easy to
   provide a portable key management protocol implementation that would
   be able to configure BEET mode SAs through the specified PF_KEY
   extensions.</t>
      <t>
   Since the BEET security associations have the semantics of a fixed,
   point-to-point tunnel between two IP addresses, it is possible to
   place one or both of the tunnel end0points into other nodes but those
   that actually "possess" the inner IP addresses, i.e., to implement a
   BEET mode proxy.  However, since such usage defeats the security
   benefits of combined ESP and hostNAT processing, as discussed above,
   the implementations SHOULD NOT support such usage. </t>
      <t>
   Because in BEET mode the outer header source address is not checked at
   the time of input handling, there is a potential for a DoS attack
   where the attacker would send random packets that match the SPI of
   some BEET-mode SA. This kind of attack would cause the victim to
   perform unnecessary integrity checks that would result in a failure.
   However, if this kind of behavior is detected, the node may request rekeying
   using IKEv2 rekey, and after rekeying. If the attacker
   was not on the path, the new SPI value would not be known by the
   attacker.
	 </t>
    </section>
    <section anchor="IKENegotiation" numbered="true" toc="default">
      <name>IKEv2 Negotiation</name>
      <t>
			When negotiating a Child SA using using IKEv2, the initiator may use
      the new "USE_BEET_MODE" Notify Message to request a Child SA pair with
      BEET mode support.  The method used is similar to how USE_TRANSPORT_MODE
			is negotiated, as described in <xref target="RFC7296"/>
			</t>
      <t>
      To request a BEET-mode SA on the Child SA pair, the initiator MUST
      include the USE_BEET_MODE Notify Message when requesting a new Child
			SA, either during the IKE_AUTH or CREATE_CHILD_SA exchanges.
			If the request is accepted, the response MUST also include a USE_BEET_MODE
			notification. If the responder declines and does not include the
			USE_BEET_MODE notification in the response, the child SA will be
			established without BEET mode enabled. If this is unacceptable to the
			initiator, the initiator MUST delete the child SA.
	 </t>
      <section title="USE_BEET_MODE Notify Message Payload" anchor="USEBeetNotify">
        <figure align="center">
          <artwork align="left"><![CDATA[
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-----------------------------+-------------------------------+
! Next Payload  !C!  RESERVED   !         Payload Length        !
+---------------+---------------+-------------------------------+
!  Protocol ID  !   SPI Size    !      Notify Message Type      !
+---------------+---------------+-------------------------------+
				 ]]></artwork>
        </figure>
        <ul>
          <li>Payload Length - MUST be 0. </li>
          <li>Protocol ID (1 octet) - MUST be 0. MUST be ignored if not 0.</li>
          <li>SPI Size (1 octet) - MUST be 0. MUST be ignored if not 0.</li>
        </ul>
      </section>
    </section>
    <section anchor="IANA" title="IANA Considerations">
      <t>
        This document defines a new IKEv2 Notify Message Type payloads for the IANA "IKEv2 Notify Message Types - Status Types" registry.
        </t>
      <figure align="center" anchor="iana_requests_i">
        <artwork align="left"><![CDATA[
      Value   Notify Type Messages - Status Types    Reference
      -----   ------------------------------    ---------------
      [TBD1]   USE_BEET_MODE                      [this document]
            ]]></artwork>
      </figure>
    </section>
    <section anchor="Implementation" numbered="true" toc="default">
      <name>Implementation Status</name>
      <t>
	 [Note to RFC Editor: Please remove this section and the reference to
      <xref target="RFC6982"/> before publication.]
	    </t>
      <t>
      This section records the status of known implementations of the
      protocol defined by this specification at the time of posting of
      this Internet-Draft, and is based on a proposal described in
      <xref target="RFC7942"/>. The description of implementations in this
      section is intended to assist the IETF in its decision processes
      in progressing drafts to RFCs. Please note that the listing of
      any individual implementation here does not imply endorsement
      by the IETF. Furthermore, no effort has been spent to verify the
      information presented here that was supplied by IETF contributors.
      This is not intended as, and must not be construed to be, a catalog
      of available implementations or their features. Readers are advised
      to note that other implementations may exist.
     </t>
      <t>
      According to <xref target="RFC7942"/>, "this will allow reviewers
      and working groups to assign due consideration to documents that
      have the benefit of running code, which may serve as evidence of
      valuable experimentation and feedback that have made the implemented
      protocols more mature.  It is up to the individual working groups
      to use this information as they see fit".
     </t>
      <t>
      Authors are requested to add a note to the RFC Editor at the
      top of this section, advising the Editor to remove the entire
      section before publication, as well as the reference to <xref target="RFC7942"/>.
     </t>
      <section anchor="impl-status.Linux.xfrm" title="Linux XFRM">
        <t> Linux </t>
        <dl>
          <dt> Organization: </dt>
          <dd> Linux kernel Project</dd>
          <dt> Name: </dt>
          <dd> Linux Kernel  https://www.kernel.org/</dd>
          <dt> Description: </dt>
          <dd> Implements BEET mode in ESP. The initial support was added in 2006. It is widely used </dd>
          <dt> Level of maturity: </dt>
          <dd> Stable used for over 15 years</dd>
          <dt> Licensing: </dt>
          <dd> GPLv2</dd>
          <dt> Implementation experience: </dt>
          <dd> There is no support for IPv4 fragments yet. IPv6 fragments
						appears to work. The BEE mode code is in production for over a decade </dd>
          <dt> Contact: </dt>
          <dd> https://lore.kernel.org/netdev/ </dd>
        </dl>
      </section>
      <section anchor="section.impl-status.strongswan" title="strongSwan">
        <dl>
          <dt> Organization: </dt>
          <dd> The strongSwan Project</dd>
          <dt> Name: </dt>
          <dd> strongSwan https://docs.strongswan.org/docs/5.9/swanctl/swanctlConf.html </dd>
          <dt> Description: </dt>
          <dd> Implement IKE negotiation and and ESP support for BEET mode Linux.</dd>
          <dt> Level of maturity: </dt>
          <dd> Stable</dd>
          <dt> Coverage: </dt>
          <dd> Implements negotiating BEET mode support in Child SA negotiations
					and using it in ESP. The initial support was added in 2006.</dd>
          <dt> Licensing: </dt>
          <dd> GPLv2</dd>
          <dt> Implementation experience </dt>
          <dd>
             strongSwan use a private space notification value for IKE
						 negotiation.  USE_BEET_MODE (40961). As far we know BEET is widely used.
            </dd>
          <dt> Contact </dt>
          <dd>Tobias Brunner tobias@strongswan.org</dd>
        </dl>
      </section>
      <section anchor="section.impl-status.iproute2" title="iproute2">
        <dl>
          <dt> Organization: </dt>
          <dd> The iproute2 Project</dd>
          <dt> Name: </dt>
          <dd> iproute2 https://git.kernel.org/pub/scm/network/iproute2/iproute2.git</dd>
          <dt> Description: </dt>
          <dd> Implements BEET mode support in ESP. e.g. command support "ip xfrm policy ... mode beet" . and "ip xfrm state .. mode beet". The initial support was added in 2006</dd>
          <dt> Level of maturity: </dt>
          <dd> Stable</dd>
          <dt> Licensing: </dt>
          <dd> GPLv2</dd>
          <dt> Implementation experience: </dt>
          <dd> TBD</dd>
          <dt> Contact: </dt>
          <dd> https://lore.kernel.org/netdev/ or Stephen Hemminger stephen@networkplumber.org </dd>
        </dl>
      </section>
    </section>
    <section anchor="Acknowledgements" numbered="true" toc="default">
      <name>Acknowledgments</name>
      <t>
    We sincerely thank the previous authors and contributors whose work laid the
		 foundation for this document. Their insights and dedication have greatly
		 influenced our work, also their contributions to the BEET mode
		 implementation many years ago.
</t>
      <t>
    Special thanks to Peka Nikander for generously granting permission to use
		their previous work <xref target="I-D.nikander-esp-beet-mode"/>.
</t>
      <t>
    We appreciate the guidance and support from Tero Kivinen in reaching out to
		previous authors during the document's development.
</t>
      <t>
    Our gratitude also goes to all those who provided feedback, guidance, and
		support throughout this document's development and operational experience.
		Your contributions were vital in making this work possible.
</t>
    </section>
  </middle>
  <back>
    <references>
      <name>Normative References</name>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4301.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4303.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7296.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.791.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8200.xml"/>
    </references>
    <references>
      <name>Informative References</name>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6982.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7942.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5201.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5202.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7401.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7402.xml"/>
      <xi:include href="https://datatracker.ietf.org/doc/bibxml3/draft-nikander-esp-beet-mode-09.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9333.xml"/>
    </references>
    <section anchor="app-additional" numbered="true" toc="default">
      <name>Additional Stuff</name>
      <t>This becomes an Appendix.</t>
    </section>
  </back>
</rfc>
